clc; 
clear all; 
close all; 

%% Constants 
%dimensions 
insz = 32*32; 
codesz = 12; 
poolsz = 3; 
outsz = codesz/poolsz; 
assert(rem(outsz,1)==0,'outsz is not an integer'); 

%loss multipliers 
wl1 = 0.5; 
ws = 0.5; 
wp = 0.5; 
%% 

%% Definitions and Initialization 
%ReLU 
ReLU = @(x) x.*(x>0); 

%input data 
x = rand(insz,3) - 0.5; 

%codes for three temporal samples 
z = ReLU(rand(codesz,3) - 0.5); 

%normalized decoder dictionary 
Wd = rand(insz,codesz) - 0.5;
Wd = Wd./repmat(sqrt(sum(Wd.^2,1)),[insz,1]); 

%pooling matrix 
r = zeros(1,codesz); 
r(1,1:poolsz) = 1; 
P = zeros(outsz,codesz); 
for ii = 1:outsz
    P(ii,:) = r; 
    r = circshift(r,[1 poolsz]); 
end

%magnitude 
m = P*z; 

%phase 
s = z./(P'*m); 
s(isnan(s))=0; %some pools are inactive 

%check that: z = ((P'*m).*s)
assert(norm(z-((P'*m).*s)) < 1e-10); 

%first moment (define coordinates from -1 to +1)  
r = zeros(1,codesz); 
r(1:poolsz) = linspace(-1,1,poolsz); 
M1 = zeros(outsz,codesz);
for ii = 1:outsz
    M1(ii,:) = r; 
    r = circshift(r,[1 poolsz]); 
end
sm1 = M1*s;

%L1-error 
El1 = sum(z(:)); 

%L2-slowness-error 
Es = sum(abs(m(:,2)-m(:,1))+abs(m(:,3)-m(:,2))); 

%Prediction-error 
Ep = 0.5*(sm1(3) - 2*sm1(2) + sm1(1)).^2;  

%L2-reconstruction-error 
Er = sum(0.5*(sum((x - Wd*z).^2,1)));












